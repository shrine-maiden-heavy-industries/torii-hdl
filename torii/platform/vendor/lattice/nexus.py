# SPDX-License-Identifier: BSD-2-Clause

from abc             import abstractmethod
from collections.abc import Iterable
from typing          import Literal

from ....build       import Attrs, Clock, Subsignal, PinFeature, TemplatedPlatform
from ....hdl         import ClockDomain, ClockSignal, Const, Instance, Module, Record, Signal
from ....lib.io      import Pin

__all__ = (
	'NexusPlatform',
)

class NexusPlatform(TemplatedPlatform):
	'''
	.. rubric:: Oxide toolchain

	Required tools:
		* ``yosys``
		* ``nextpnr-nexus``
		* ``prjoxide``

	The environment is populated by running the script specified in the environment variable
	``TORII_ENV_OXIDE``, if present.

		Available overrides:
		* ``verbose``: enables logging of informational messages to standard error.
		* ``read_verilog_opts``: adds options for ``read_verilog`` Yosys command.
		* ``synth_opts``: adds options for ``synth_lattice`` Yosys command.
		* ``script_after_read``: inserts commands after ``read_rtlil`` in Yosys script.
		* ``script_after_synth``: inserts commands after ``synth_lattice`` in Yosys script.
		* ``yosys_opts``: adds extra options for ``yosys``.
		* ``nextpnr_opts``: adds extra options for ``nextpnr-nexus``.
		* ``prjoxide_opts``: adds extra options for ``prjoxide``.
		* ``add_preferences``: inserts commands at the end of the LPF file.

	Build products:
		* ``{{name}}.rpt``: Yosys log.
		* ``{{name}}.json``: synthesized RTL.
		* ``{{name}}.tim``: nextpnr log.
		* ``{{name}}.fasm``: ASCII bitstream.
		* ``{{name}}.bit``: binary bitstream.

	.. rubric:: Radiant toolchain

	Required tools:
		* ``radiantc``

	The environment is populated by running the script specified in the environment variable
	``TORII_ENV_RADIANT``, if present. On Linux, ``radiant_env`` as provided by Radiant
	itself is a good candidate.

	Available overrides:
		* ``script_project``: inserts commands before ``prj_project save`` in Tcl script.
		* ``script_after_export``: inserts commands after ``prj_run Export`` in Tcl script.
		* ``add_preferences``: inserts commands at the end of the LPF file.
		* ``add_constraints``: inserts commands at the end of the XDC file.

	Build products:
		* ``{{name}}_impl/{{name}}_impl.htm``: consolidated log.
		* ``{{name}}.bit``: binary bitstream.
	'''

	toolchain = None

	@property
	@abstractmethod
	def device(self) -> str:
		raise NotImplementedError('Platform must implement this property')

	@property
	@abstractmethod
	def package(self) -> str:
		raise NotImplementedError('Platform must implement this property')

	@property
	@abstractmethod
	def speed(self) -> str:
		raise NotImplementedError('Platform must implement this property')

	grade   = 'C' # [C]ommercial, [I]ndustrial

	osca_div = 2

	# Oxide templates

	_oxide_required_tools = [
		'yosys',
		'nextpnr-nexus',
		'prjoxide'
	]

	_oxide_file_templates = {
		**TemplatedPlatform.build_script_templates,
		'{{name}}.il': r'''
			# {{autogenerated}}
			{{emit_rtlil()}}
		''',
		'{{name}}.debug.v': r'''
			/* {{autogenerated}} */
			{{emit_debug_verilog()}}
		''',
		'{{name}}.ys': r'''
			# {{autogenerated}}
			{% for file in platform.iter_files(".v") -%}
				read_verilog {{get_override("read_verilog_opts")|options}} {{file}}
			{% endfor %}
			{% for file in platform.iter_files(".sv") -%}
				read_verilog -sv {{get_override("read_verilog_opts")|options}} {{file}}
			{% endfor %}
			{% for file in platform.iter_files(".il") -%}
				read_rtlil {{file}}
			{% endfor %}
			read_rtlil {{name}}.il
			{{get_override("script_after_read")|default("# (script_after_read placeholder)")}}
			synth_lattice -family {{ platform.device.split('-')[0]|lower}} {{get_override("synth_opts")|options}} -top {{name}}
			{{get_override("script_after_synth")|default("# (script_after_synth placeholder)")}}
			write_json {{name}}.json
		''', # noqa: E501
		'{{name}}.pdc': r'''
			# {{autogenerated}}
			{% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
				{% if port_signal is not none -%}
					create_clock -name {{port_signal.name|tcl_quote}} -period {{frequency.period.nanoseconds}} [get_nets {{port_signal.name|tcl_quote}}]
				{% else -%}
					create_clock -name {{net_signal.name|tcl_quote}} -period {{frequency.period.nanoseconds}} [get_nets {{net_signal|hierarchy("/")|tcl_quote}}]
				{% endif %}
			{% endfor %}

			{% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
				ldc_set_location -site {{'{'}}{{pin_name}}{{'}'}} [get_ports {{'{'}}{{port_name}}{{'}'}}]
				{% if attrs -%}
				ldc_set_port -iobuf {{'{'}}{%- for key, value in attrs.items() %} {{key}}={{value}}{% endfor %}{{'}'}} [get_ports {{'{'}}{{port_name}}{{'}'}}]
				{% endif %}
			{% endfor %}

			{{get_override("add_preferences")|default("# (add_preferences placeholder)")}}
		''', # noqa: E501
	}

	_oxide_command_templates = [
		r'''
		{{invoke_tool("yosys")}}
			{{quiet("-q")}}
			{{get_override("yosys_opts")|options}}
			-l {{name}}.rpt
			{{name}}.ys
		''',
		r'''
		{{invoke_tool("nextpnr-nexus")}}
			{{quiet("--quiet")}}
			{{get_override("nextpnr_opts")|options}}
			--log {{name}}.tim
			--device {{platform.device}}-{{platform.speed}}{{platform.package|upper}}{{platform.grade}}
			--json {{name}}.json
			--pdc {{name}}.pdc
			--fasm {{name}}.fasm
		''',
		r'''
		{{invoke_tool("prjoxide")}}
			{{verbose("--verbose")}}
			{{get_override("prjoxide_opts")|options}}
			pack {{name}}.fasm {{name}}.bit
		'''
	]

	# Radiant templates

	_radiant_required_tools = [
		'radiantc',
	]

	_radiant_file_templates = {
		**TemplatedPlatform.build_script_templates,
		'build_{{name}}.sh': r'''
			#!/bin/sh
			# {{autogenerated}}
			set -e{{verbose("x")}}
			if [ -z "$BASH" ] ; then exec /bin/bash "$0" "$@"; fi
			if [ -n "${{platform._toolchain_env_var}}" ]; then
				bindir=$(dirname "${{platform._toolchain_env_var}}")
				. "${{platform._toolchain_env_var}}"
			fi
			{{emit_commands("sh")}}
		''',
		'{{name}}.v': r'''
			/* {{autogenerated}} */
			{{emit_verilog()}}
		''',
		'{{name}}.debug.v': r'''
			/* {{autogenerated}} */
			{{emit_debug_verilog()}}
		''',
		'{{name}}.tcl': r'''
			# {{autogenerated}}
			prj_create -name {{name}} \
				-impl {{name}} \
				-dev {{platform.device}}-{{platform.speed}}{{platform.package}}{{platform.grade}} \
				-synthesis synplify
			{% for f in platform.iter_files(".v", ".sv", ".vhd", ".vhdl") -%}
				prj_add_sources {{file|tcl_quote}}
			{% endfor %}
			prj_add_source {{name}}.v
			prj_add_source {{name}}.pdc
			prj_add_source {{name}}.sdc
			prj_set_impl_opt top \"{{name}}\"
			{{get_override("script_project")|default("# (script_project placeholder)")}}
			prj_save
			prj_run_synthesis -forceOne
			prj_run_map
			prj_run_par
			prj_run_bitstream
			{{get_override("script_after_export")|default("# (script_after_export placeholder)")}}
		''',
		'{{name}}.pdc': r'''
			# {{autogenerated}}
			{% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
				ldc_set_location -site {{'{'}}{{pin_name}}{{'}'}} [get_ports {{'{'}}{{port_name}}{{'}'}}]
				{% if attrs -%}
				ldc_set_port -iobuf {{'{'}}{%- for key, value in attrs.items() %} {{key}}={{value}}{% endfor %}{{'}'}} [get_ports {{'{'}}{{port_name}}{{'}'}}]
				{% endif %}
			{% endfor %}

			{{get_override("add_preferences")|default("# (add_preferences placeholder)")}}
		''',  # noqa: E501
		'{{name}}.sdc': r'''
			# {{autogenerated}}
			{% for net_signal, port_signal, frequency in platform.iter_clock_constraints() -%}
				{% if port_signal is not none -%}
					create_clock -name {{port_signal.name|tcl_quote}} -period {{frequency.period.nanoseconds}} [get_nets {{port_signal.name|tcl_quote}}]
				{% else -%}
					create_clock -name {{net_signal.name|tcl_quote}} -period {{frequency.period.nanoseconds}} [get_nets {{net_signal|hierarchy("/")|tcl_quote}}]
				{% endif %}
			{% endfor %}
		''',  # noqa: E501
	}

	_radiant_command_templates = [
		r'''
		{{invoke_tool("radiantc")}}
			{{name}}.tcl
		'''
	]

	def __init__(self, *, toolchain: Literal['Oxide', 'Radiant'] = 'Oxide') -> None:
		super().__init__()

		if toolchain not in ('Oxide', 'Radiant'):
			raise ValueError(f'Unknown toolchain \'{self.toolchain}\', must be either \'Oxide\', or \'Radiant\'')

		self.toolchain = toolchain

	@property
	def required_tools(self) -> list[str]:
		if self.toolchain not in ('Oxide', 'Radiant'):
			raise ValueError(f'Unknown toolchain \'{self.toolchain}\', must be either \'Oxide\', or \'Radiant\'')

		if self.toolchain == 'Oxide':
			return self._oxide_required_tools
		if self.toolchain == 'Radiant':
			return self._radiant_required_tools

	@property
	def file_templates(self) -> dict[str, str]:
		if self.toolchain not in ('Oxide', 'Radiant'):
			raise ValueError(f'Unknown toolchain \'{self.toolchain}\', must be either \'Oxide\', or \'Radiant\'')

		if self.toolchain == 'Oxide':
			return self._oxide_file_templates
		if self.toolchain == 'Radiant':
			return self._radiant_file_templates

	@property
	def command_templates(self) -> list[str]:
		if self.toolchain not in ('Oxide', 'Radiant'):
			raise ValueError(f'Unknown toolchain \'{self.toolchain}\', must be either \'Oxide\', or \'Radiant\'')

		if self.toolchain == 'Oxide':
			return self._oxide_command_templates
		if self.toolchain == 'Radiant':
			return self._radiant_command_templates

	@property
	def default_clk_constraint(self) -> Clock:
		if self.default_clk == 'OSCA':
			return Clock(int(450e6 / self.osca_div))
		return super().default_clk_constraint

	def create_missing_domain(self, name: str) -> Module:
		if name == 'sync' and self.default_clk is not None:
			m = Module()

			if self.default_clk == 'OSCA':
				if self.osca_div > 256 or self.osca_div < 2:
					raise ValueError(f'OSCA divisor must be between 2 and 256, not {self.osca_div}')

				clk = Signal()
				m.submodules += [
					Instance(
						'OSCA',
						p_HF_CLK_DIV = f'{self.osca_div - 1}',
						i_HFOUTEN = Const(1),
						i_HFSDSCEN = Const(0),
						o_HFCLKOUT = clk
					)
				]
			else:
				clk = self.request(self.default_clk).i

			if self.default_rst is not None:
				rst = self.request(self.default_rst).i
			else:
				rst = Const(0)

			gsr0 = Signal()
			gsr1 = Signal()

			# Lattice Nexus parts *still* don't have an end-of-startup signal, so we still
			# rely on the PUR on some dummy flops to manually assert the GSR and then kick
			# things off

			m.submodules += [
				Instance(
					'FD1P3BX', p_GSR = 'DISABLED', i_CK = clk, i_SP = Const(1), i_PD = Const(0), i_D = ~rst, o_Q = gsr0
				),
				Instance(
					'FD1P3BX', p_GSR = 'DISABLED', i_CK = clk, i_SP = Const(1), i_PD = Const(0), i_D = gsr0, o_Q = gsr1
				),
				Instance('GSR', p_SYNCMODE = 'SYNC', i_CLK = clk, i_GSR_N = gsr1)
			]

			m.domains += [
				ClockDomain('sync', reset_less = True)
			]
			m.d.comb += [
				ClockSignal('sync').eq(clk)
			]

			return m
		else:
			return None

	def should_skip_port_component(
		self, port: Subsignal, attrs: Attrs, component: Literal['io', 'i', 'o', 'p', 'n', 'oe']
	) -> bool:
		# TODO
		return False

	def _get_xdr_buffer(
		self, m: Module, pin: Pin, *, i_invert: bool = False, o_invert: bool = False
	) -> tuple[Signal | None, Signal | None, Signal | None]:
		if pin.xdr not in (0, 1, 2, 4, 7, 8, 10):
			raise ValueError(f'Invalid gearing {pin.xdr} for pin {pin.name}, must be one of, 0, 1, 2, 4, 7, 8, or 10')

		def get_ireg(clk: Signal, d: Signal, q: Signal) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'IFD1P3DX',
						i_CK = clk,
						i_SP = Const(1),
						i_CD = Const(0),
						i_D = d[bit],
						o_Q = q[bit]
					)
				]

		def get_oreg(clk: Signal, d: Signal, q: Signal) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'OFD1P3DX',
						i_CK = clk,
						i_SP = Const(1),
						i_CD = Const(0),
						i_D = d[bit],
						o_Q = q[bit]
					)
				]

		def get_oereg(clk: Signal, oe: Signal, q: Signal) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'OFD1P3DX',
						i_CK = clk,
						i_SP = Const(1),
						i_CD = Const(0),
						i_D = oe,
						o_Q = q[bit]
					)
				]

		def get_iddr(sclk: Signal, d: Signal, q0: Signal, q1: Signal) -> None:
			for bit in range(len(d)):
				m.submodules += [
					Instance(
						'IDDRX1',
						i_SCLK = sclk,
						i_RST = Const(0),
						i_D = d[bit],
						o_Q0 = q0[bit],
						o_Q1 = q1[bit],
					)
				]

		def get_iddrx2(
			sclk: Signal, eclk: Signal, d: Signal, q0: Signal, q1: Signal, q2: Signal, q3: Signal
		) -> None:
			for bit in range(len(d)):
				m.submodules += [
					Instance(
						'IDDRX2',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D = d[bit],
						o_Q0 = q0[bit],
						o_Q1 = q1[bit],
						o_Q2 = q2[bit],
						o_Q3 = q3[bit],
					)
				]

		def get_iddr71b(
			sclk: Signal, eclk: Signal, d: Signal,
			q0: Signal, q1: Signal, q2: Signal, q3: Signal, q4: Signal, q5: Signal, q6: Signal
		) -> None:
			for bit in range(len(d)):
				m.submodules += [
					Instance(
						'IDDR71',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D = d[bit],
						o_Q0 = q0[bit],
						o_Q1 = q1[bit],
						o_Q2 = q2[bit],
						o_Q3 = q3[bit],
						o_Q4 = q4[bit],
						o_Q5 = q5[bit],
						o_Q6 = q6[bit],
					)
				]

		def get_iddrx4(
			sclk: Signal, eclk: Signal, d: Signal,
			q0: Signal, q1: Signal, q2: Signal, q3: Signal, q4: Signal, q5: Signal, q6: Signal, q7: Signal
		) -> None:
			for bit in range(len(d)):
				m.submodules += [
					Instance(
						'IDDRX4',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D = d[bit],
						o_Q0 = q0[bit],
						o_Q1 = q1[bit],
						o_Q2 = q2[bit],
						o_Q3 = q3[bit],
						o_Q4 = q4[bit],
						o_Q5 = q5[bit],
						o_Q6 = q6[bit],
						o_Q7 = q7[bit],
					)
				]

		def get_iddrx5(
			sclk: Signal, eclk: Signal, d: Signal,
			q0: Signal, q1: Signal, q2: Signal, q3: Signal, q4: Signal, q5: Signal, q6: Signal, q7: Signal, q8: Signal,
			q9: Signal
		) -> None:
			for bit in range(len(d)):
				m.submodules += [
					Instance(
						'IDDRX5',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D = d[bit],
						o_Q0 = q0[bit],
						o_Q1 = q1[bit],
						o_Q2 = q2[bit],
						o_Q3 = q3[bit],
						o_Q4 = q4[bit],
						o_Q5 = q5[bit],
						o_Q6 = q6[bit],
						o_Q7 = q7[bit],
						o_Q8 = q8[bit],
						o_Q9 = q9[bit],
					)
				]

		def get_oddr(sclk: Signal, d0: Signal, d1: Signal, q: Signal) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'ODDRX1',
						i_SCLK = sclk,
						i_RST = Const(0),
						i_D0 = d0[bit],
						i_D1 = d1[bit],
						o_Q = q[bit],
					)
				]

		def get_oddrx2(
			sclk: Signal, eclk: Signal, d0: Signal, d1: Signal, d2: Signal, d3: Signal, q: Signal
		) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'ODDRX2',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D0 = d0[bit],
						i_D1 = d1[bit],
						i_D2 = d2[bit],
						i_D3 = d3[bit],
						o_Q = q[bit],
					)
				]

		def get_oddr71b(
			sclk: Signal, eclk: Signal,
			d0: Signal, d1: Signal, d2: Signal, d3: Signal, d4: Signal, d5: Signal, d6: Signal,
			q: Signal,
		) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'ODDR71',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D0 = d0[bit],
						i_D1 = d1[bit],
						i_D2 = d2[bit],
						i_D3 = d3[bit],
						i_D4 = d4[bit],
						i_D5 = d5[bit],
						i_D6 = d6[bit],
						o_Q = q[bit],
					)
				]

		def get_oddrx4(
			sclk: Signal, eclk: Signal,
			d0: Signal, d1: Signal, d2: Signal, d3: Signal, d4: Signal, d5: Signal, d6: Signal, d7: Signal, q: Signal
		) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'ODDRX4',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D0 = d0[bit],
						i_D1 = d1[bit],
						i_D2 = d2[bit],
						i_D3 = d3[bit],
						i_D4 = d4[bit],
						i_D5 = d5[bit],
						i_D6 = d6[bit],
						i_D7 = d7[bit],
						o_Q = q[bit],
					)
				]

		def get_oddrx5(
			sclk: Signal, eclk: Signal,
			d0: Signal, d1: Signal, d2: Signal, d3: Signal, d4: Signal, d5: Signal, d6: Signal, d7: Signal, d8: Signal,
			d9: Signal, q: Signal
		) -> None:
			for bit in range(len(q)):
				m.submodules += [
					Instance(
						'ODDRX5',
						i_SCLK = sclk,
						i_ECLK = eclk,
						i_RST = Const(0),
						i_D0 = d0[bit],
						i_D1 = d1[bit],
						i_D2 = d2[bit],
						i_D3 = d3[bit],
						i_D4 = d4[bit],
						i_D5 = d5[bit],
						i_D6 = d6[bit],
						i_D7 = d7[bit],
						i_D8 = d8[bit],
						i_D9 = d9[bit],
						o_Q = q[bit],
					)
				]

		def get_ineg(z: Signal, invert: bool) -> Signal:
			if invert:
				a = Signal.like(z, name_suffix = '_n')
				m.d.comb += [ z.eq(~a) ]
				return a
			return z

		def get_oneg(a: Signal, invert: bool) -> Signal:
			if invert:
				z = Signal.like(a, name_suffix = '_n')
				m.d.comb += [ a.eq(~z) ]
				return z
			return a

		i: Signal | None = None
		o: Signal | None = None
		t: Signal | None = None

		if 'i' in pin.dir:
			i = Signal(pin.width, name = f'{pin.name}_xdr_i')
			if pin.xdr == 1:
				i = get_ineg(pin.i, i_invert)
			elif pin.xdr == 2:
				get_ireg(pin.i_clk, i, get_ineg(pin.i, i_invert))
			elif pin.xdr == 2:
				get_iddr(
					pin.i_clk,
					i,
					get_ineg(pin.i0, i_invert),
					get_ineg(pin.i1, i_invert),
				)
			elif pin.xdr == 4:
				get_iddrx2(
					pin.i_clk,
					pin.i_fclk,
					i,
					get_ineg(pin.i0, i_invert),
					get_ineg(pin.i1, i_invert),
					get_ineg(pin.i2, i_invert),
					get_ineg(pin.i3, i_invert),
				)
			elif pin.xdr == 7:
				get_iddr71b(
					pin.i_clk,
					pin.i_fclk,
					i,
					get_ineg(pin.i0, i_invert),
					get_ineg(pin.i1, i_invert),
					get_ineg(pin.i2, i_invert),
					get_ineg(pin.i3, i_invert),
					get_ineg(pin.i4, i_invert),
					get_ineg(pin.i5, i_invert),
					get_ineg(pin.i6, i_invert),
				)
			elif pin.xdr == 8:
				get_iddrx4(
					pin.i_clk,
					pin.i_fclk,
					i,
					get_ineg(pin.i0, i_invert),
					get_ineg(pin.i1, i_invert),
					get_ineg(pin.i2, i_invert),
					get_ineg(pin.i3, i_invert),
					get_ineg(pin.i4, i_invert),
					get_ineg(pin.i5, i_invert),
					get_ineg(pin.i6, i_invert),
					get_ineg(pin.i7, i_invert),
				)
			elif pin.xdr == 10:
				get_iddrx5(
					pin.i_clk,
					pin.i_fclk,
					i,
					get_ineg(pin.i0, i_invert),
					get_ineg(pin.i1, i_invert),
					get_ineg(pin.i2, i_invert),
					get_ineg(pin.i3, i_invert),
					get_ineg(pin.i4, i_invert),
					get_ineg(pin.i5, i_invert),
					get_ineg(pin.i6, i_invert),
					get_ineg(pin.i7, i_invert),
					get_ineg(pin.i8, i_invert),
					get_ineg(pin.i9, i_invert),
				)
		if 'o' in pin.dir:
			o = Signal(pin.width, name = f'{pin.name}_xdr_o')
			if pin.xdr == 1:
				o = get_oneg(pin.o, o_invert)
			elif pin.xdr == 2:
				get_oreg(pin.o_clk, get_oneg(pin.o, o_invert), o)
			elif pin.xdr == 2:
				get_oddr(
					pin.o_clk,
					get_oneg(pin.o0, o_invert),
					get_oneg(pin.o1, o_invert),
					o,
				)
			elif pin.xdr == 4:
				get_oddrx2(
					pin.o_clk,
					pin.o_fclk,
					get_oneg(pin.o0, o_invert),
					get_oneg(pin.o1, o_invert),
					get_oneg(pin.o2, o_invert),
					get_oneg(pin.o3, o_invert),
					o,
				)
			elif pin.xdr == 7:
				get_oddr71b(
					pin.o_clk,
					pin.o_fclk,
					get_oneg(pin.o0, o_invert),
					get_oneg(pin.o1, o_invert),
					get_oneg(pin.o2, o_invert),
					get_oneg(pin.o3, o_invert),
					get_oneg(pin.o4, o_invert),
					get_oneg(pin.o5, o_invert),
					get_oneg(pin.o6, o_invert),
					o,
				)
			elif pin.xdr == 8:
				get_oddrx4(
					pin.o_clk,
					pin.o_fclk,
					get_oneg(pin.o0, o_invert),
					get_oneg(pin.o1, o_invert),
					get_oneg(pin.o2, o_invert),
					get_oneg(pin.o3, o_invert),
					get_oneg(pin.o4, o_invert),
					get_oneg(pin.o5, o_invert),
					get_oneg(pin.o6, o_invert),
					get_oneg(pin.o7, o_invert),
					o,
				)
			elif pin.xdr == 10:
				get_oddrx5(
					pin.o_clk,
					pin.o_fclk,
					get_oneg(pin.o0, o_invert),
					get_oneg(pin.o1, o_invert),
					get_oneg(pin.o2, o_invert),
					get_oneg(pin.o3, o_invert),
					get_oneg(pin.o4, o_invert),
					get_oneg(pin.o5, o_invert),
					get_oneg(pin.o6, o_invert),
					get_oneg(pin.o7, o_invert),
					get_oneg(pin.o8, o_invert),
					get_oneg(pin.o9, o_invert),
					o,
				)

		if pin.dir in ('oe', 'io'):
			t = Signal(pin.width, name = f'{pin.name}_xdr_t')
			if pin.xdr == 0:
				t = ~pin.oe.replicate(pin.width)
			elif pin.xdr == 1:
				get_oereg(pin.o_clk, ~pin.oe, t)

		return (i, o, t)

	def get_input(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: Iterable[str]
	) -> Module:
		self._check_feature(
			PinFeature.SE_INPUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		i, _, _ = self._get_xdr_buffer(m, pin, i_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'IB',
				i_I = port.io[bit],
				o_O = i[bit]
			)

		return m

	def get_output(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: Iterable[str]
	) -> Module:
		self._check_feature(
			PinFeature.SE_OUTPUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		_, o, _ = self._get_xdr_buffer(m, pin, o_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'OB',
				i_I = o[bit],
				o_O = port.io[bit]
			)

		return m

	def get_tristate(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: Iterable[str]
	) -> Module:
		self._check_feature(
			PinFeature.SE_TRISTATE, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		_, o, t  = self._get_xdr_buffer(m, pin, o_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'OBZ',
				i_I = o[bit],
				i_T = t[bit],
				o_O = port.io[bit]
			)

		return m

	def get_input_output(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: Iterable[str]
	) -> Module:
		self._check_feature(
			PinFeature.SE_INOUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		i, o, t  = self._get_xdr_buffer(m, pin, i_invert = invert, o_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'BB',
				i_I = o[bit],
				i_T = t[bit],
				o_O = i[bit],
				io_B = port.io[bit]
			)

		return m

	def get_diff_input(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: tuple[Iterable[str], Iterable[str]]
	) -> Module:
		self._check_feature(
			PinFeature.DIFF_INPUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		i, _, _ = self._get_xdr_buffer(m, pin, i_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'IB',
				i_I = port.p[bit],
				o_O = i[bit]
			)

		return m

	def get_diff_output(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: tuple[Iterable[str], Iterable[str]]
	) -> Module:
		self._check_feature(
			PinFeature.DIFF_OUTPUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		_, o, _ = self._get_xdr_buffer(m, pin, o_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'OB',
				i_I = o[bit],
				o_O = port.p[bit]
			)

		return m

	def get_diff_tristate(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: tuple[Iterable[str], Iterable[str]]
	) -> Module:
		self._check_feature(
			PinFeature.DIFF_TRISTATE, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		_, o, t = self._get_xdr_buffer(m, pin, o_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'OBZ',
				i_I = o[bit],
				i_T = t[bit],
				o_O = port.p[bit]
			)

		return m

	def get_diff_input_output(
		self, pin: Pin, port: Record, attrs: Attrs, invert: bool, names: tuple[Iterable[str], Iterable[str]]
	) -> Module:
		self._check_feature(
			PinFeature.DIFF_INOUT, pin, attrs, valid_xdrs = (0, 1, 2, 4, 7, 8, 10), valid_attrs = True, names = names
		)

		m = Module()
		i, o, t = self._get_xdr_buffer(m, pin, i_invert = invert)
		for bit in range(pin.width):
			m.submodules[f'{pin.name}_{bit}'] = Instance(
				'BB',
				i_I = o[bit],
				i_T = t[bit],
				o_O = i[bit],
				io_B = port.p[bit],
			)

		return m
